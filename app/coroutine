
2.Coroutine
    Coroutine은 Thread안에 여러개로 존재할 수 있는 작업 아이템이다. 라이트한 Thread와 같다고 표현하기도 한다. 아래를 보면
    Coroutine의 delay메소드가 있는데 Coroutinedml delay는 해당 Thread에 대한 것이 아니라 Thread안에 Coroutine에
    대한 delay이다.

    ------------------------------------------------------------------------------------------------
    delay(8000)
    ------------------------------------------------------------------------------------------------

    Thread.sleep()이 해당 쓰레드에 대한 delay를 시키는 것인데 반해, Coroutine의 delay는 Thread안에 있는 자신에 대한
    delay만 발생시킨다. Coroutine과 Thread가 다른 개념이라는 것을 알고 있어야 Coroutine의 다른 함수들을 올바르게 사용
    할 수 있다.

3. 구현
    Coroutine을 정의하고 시작하는 방법등에 대해서 정리해 보겠다. 가장 먼저 할일은 Coroutine들이 작업될 수 있는 Scope를 정의
    하는 것이다. Scope를 정한 후에는 launch 또는 async메소드를 이용해 작업을 시작해 줄 수 있다.

3 - 1. Coroutine Scope
    위에서 Coroutine이 특정 Thread에서 할 수 있는 작업들 이라고 하였는데, 이 작업들의 범위를 정한다는 것은 어떤 Thread에서
    할 것이냐를 정의하는 것이기도 하다. 밑에서 산텍할 수 이쓴 상수값들을 보겠다.
    ------------------------------------------------------------------------------------------------
    btn_coroutine.setOnClickListener{
        CoroutineScope(IO).launch{
            testRequest()
        }
    }
    ------------------------------------------------------------------------------------------------

    CoroutineScope에는 IO, Main, Default 중 하느를 인자로 넣어서 Coroutine코드들의 scope를 정의할 수 있다. 이들은
    Coroutine을 suspend하거나 resume할 수 있는 dispatcher들로, 어떤 Thread에서 어떻게 동작할지에 대한 정보를담고 있다.

    각각의 용도는 다음과 같다.
    - Dispatchers.IO : disk또는 network/IO에 최적화 되어 워커쓰레드에서 돌아간다.
    - Dispatchers.Default : CPU 연산이 많이 필요한 JSON파싱 혹은 긴 LisgSorting등에 최적화 되어 있다.
    - Dispatchers.Main : UI와 상호작용을 하거나 정말 간단한 작업등에 사용할 수 있다.

    CoroutineScope는 Coroutine을 시작하는 곳이기도 하지만, 모든 Coroutine을 관리하는 곳이기도 한며 Coroutine을 끝내는
    곳이기도 한다. 어떤 비동기 코드도 Coroutine이끝나면 같이 끝나버린다.

    이런점이 코딩을 할때 주의를 기울여야 하는 부분이기도 하지만, 안드로이드 같이 lifeCycle에 따라 리소스에 대한 release가
    중요한 프레임워크에서는 매우 편리한 부분이기도 하다. Scope가 끝나면 모든 작업이 끝난다는 것을 보장해 주기 때문이다.

3 - 2. Suspend & Resume
    Coroutine을 사용하면서 Suspend와 Resume에 대한 개념을 잠시 알고 갈 필요가 있다.
    - Suspend : 모든 로컬변수를 저장하고 현 Scope에서의 코루틴의 실행을 pause한다.
    - Resume : pause됬던 곳에서, 코루틴을 계속 실행한다.

    Suspend & Reusme기능은 kotlins의 function에 suspend라는 키워드를 붙이거나 launch나 async처럼 코틀린을 시작하는
    함수를 사용함으로서 더해지게 된다.

    Corouine의 스코프에서 사용되어 지는 함수는 suspend라는 키워드를 아래와 같이 붙여 주어야 한다.

    ------------------------------------------------------------------------------------------------
    private suspend fun startTimeout(){
        mCoroutineScope
            .launch{
                val mCoroutine1 =
                    withTimeOrNull(TIMEOUT_SECONES){
                }
            }
    }
    private suspend fun testRequest(){
        showAtMainTread(test1())
        showAtMainTread(test2())
    }
    ------------------------------------------------------------------------------------------------

3 - 2.Coroutine을 시작하는 방법(launch & async)
    위의 코드들에서 launch함수를 봤을 것이다.
    - launch : 새로운 Coroutine을 시작하지만, 결과값을 전달하지 않을 떄 사용한다.
    - async : result를 return할 수 있는 Coroutine을 시작하는 경우 이 메소드를 사용해 준다.

    둘의 가장 큰 차이는 return값이 있느냐 없느냐 이다. 어느 것을 사용하느냐에 따라서 사용하는 메소드나 완료대기에 대한 대응이
    조금씩 달라진다.

3 - 3. Job과 Deferred(연기 혹은 완료 대기)
    A. launch함수의 job
    launch함수로 시작한 Coroutine은 Job타입의 객체를 리턴한다. 아래와 같이 return된 job에 join()함수를 이용해서, 코드가
    완료될 때까지 기다릴 수 있다. Job이 여러개인 경우에는 joinAll()함수를 이용해 모든 Coroutine이 완료 되는 것을 기다릴
    수도 있다.

    ------------------------------------------------------------------------------------------------
    val mCoroutineScope = CoroutineScope(IO)
    private suspend fun start(){
        val mJob = mCoroutineScope.launch{...}
        mJob.join()
    }
    ------------------------------------------------------------------------------------------------

    B. async함수의 Deferred
    async는 return할 결과 값이 있는데, Deffered<T>타입으로 객체를 return해 준다. async함수는 await()함수로 완료가
    되기를 기다릴 수 있다. 특히 suspend키워드로 시작한 코루틴은 해당 함수가 return하는 시점에는 작업이 멈춰있어야 하므로,
    await()이나 awaitAll()을 이용해서 retur전에 결과값을 가지도록 해 주어야 한다.

    ------------------------------------------------------------------------------------------------
    val mDeferred = mCoroutineScope.async{...}
    mDeferred.await()
    ------------------------------------------------------------------------------------------------

    async는 return할 값이 있으므로 launch함수의 join()을 사용할 때 보다 return이나 exception처리에 있어서 주의가 필요하다.

    - await이 호출되면, await호출시에 exception을 들고 있다가 다시 rethrow해 주는데 await호출시 새로운 coroutine호출시
    새로운 코루틴을 실행시키면 exception이 drop되어 버릴 수가 있다.
    - 여러개의 async가 존재하는 경우, 첫번째 async의 리턴값만을 리턴해 준다.

    c. runBlocking
    runBlocking을 이용해서 Block내의 코드가 실행 완료될때 까지 Blocking을 해서 기다리게 할 수 있다. 단순히 Join같은
    메소드와 같은 기능이 아니라, 현재 thread를 block하고 실행되는 코드이므로 main쓰래드에서 이용하는 것은 좋은 방법이 아니다.

    ------------------------------------------------------------------------------------------------
    runBlocking{
        delay(3000)
        print("Block End")
    }
    ------------------------------------------------------------------------------------------------
    그리고 runBlocking에 관한 공식문서를 보면, 중요한 부분이 있다. 이 함수는 coroutine으로부터 사용되어서는 않된다는 것이다.
    어려운 이야기지만 일반적으로, Blocking코드와 suspend스타일로 적힌 라이브러리들을 bridge해줄 목적으로 설계된함수여서,
    main functions 나 테스트들에서 사용되어져야 한다고 한다.

3 - 4. Lazy한 Coroutine 실행 방법
    Coroutine은 launch나 async메소드가 실행되면 바로 시작 되지만 이를 지연해서 실행시킬수 있다. launch나 async함수에
    인자로 "start = CoroutineStart.Lazy"를 아래와 같이 넣어주면 된다.
    - return 값이 없는 launch의 경우 start()를 실행해 주거나, join()을 실행해주는 순간 실행되게 되므로, 둘을 실행하는데
    큰 차이는 없다.
    - async의 경우는 start()를 실행하는 경우나 await()이 실행되는 경우 모두 시작은 되지만, start()는 결과값을 return해
    주지 않으며, await()과는 다르게 Coroutine코드가 완료될 때까지 기다리지 않는다.

    ------------------------------------------------------------------------------------------------
    fun test() = runBlocking<Unit>{
        val one = async(start = CoroutineStart.Lazy){testOne()}
        val two = async(start = CoroutineStart.Lazy){testTwo()}
        one.start()
        two.start()
        println("결과는 ${one.await() + two.await()}")
    }
    suspend fun testOne(): Int{delat(1*1000); return 6}
    suspend fun testTwo(): Int{delat(1*1000); return 8}
    ------------------------------------------------------------------------------------------------

3 - 5. 작업의 취소
    a.cancel
    기본적인 취소는 launch나 async메소드로 시작하여 얻은 job이나 deffered객체에 cancel()함수를사용해 주면 된다.

    ------------------------------------------------------------------------------------------------
    private fun testRun() = runBlocking{
        val mJob: job = launch{
            repeat(10){ i ->
                delay(100)
                Log.d("Coroutine", i.toString())
            }
        }
        delay(1000)
        Log.d("Coroutine", "ready for cancel")
        mJob.caoncel()
        mJob.join()
        Log.d("Coroutine", "now quit")
    }
    ------------------------------------------------------------------------------------------------

    위의 코드를 빌드해보면 cancel과 join이 잘 동작하는 것을 볼수 있다.(이 두 동작을 한번에 할 수 있는 cancelAndJoin()이라는
    함수도 있다.)

    하지만 cancel()이 잘 동작하지 않는 경우가 있는데, 복잡한 computation을 하고 있을 경우, cancel에 대해 확인하거나 yeild()
    라는 함수를 호출해서 cancel()에 대해서 확인해야 한다.

    b. withTimeoutOrNull
    만약 네트워크 호출을 하였는데 서버의 상태가 좋지 못하다거나, 디스크 입출력을 하다가 에러가 났다면, 해당 작업을 취소하고 유저에게
    알려주는 등의 작업을 해야 한다.

    이러한 이유로, 실제 프로덕트에서 중요한 부분은 Timeout과 관련된 부분일 것이다. Coroutine은 이럴 때 사용하기 쉬은 함수를
    제공해 주고 있다. withTimeoutOrNull이다. 인자에 시간을 넣어주고 메소드를 실행시켜 준다. 해당 시간이 지나도 정상적으로
    종료되지 않으면, null을 반환하므로, 이 null값을 이용해서 유저에게 정보를 알려줄수 있다.

    ------------------------------------------------------------------------------------------------
    val mDeferred = mCoroutineScpe.async{
        val mCoroutine1 = withTimeoutOrNull(TIMEOUT_SECONDS){
            testRequest()
        }
        if(mCoroutine1 == null){
            Toast.makeText(
                this@MainActivity,
                "네트워크 상태가 좋지 않아서 정보가 없습니다. 다시 리프레쉬를 눌러 주헤요",
                Toast.LENGTH_SHORT)
                .show()
        }
    }
    mDeffered.await()
    ------------------------------------------------------------------------------------------------

    c. Scope와 관련된 주의 사항
    Scope객체는 모든 Coroutine에 대해서 관리하고 있기 때문에, 한 Scope가 끝나면 해당 Scope에서의 모든 동작이 다 cancel
    되어 버린다. 그것이 비동기 동작이어서 언제 끝날지 모르는 작업이라 할지라도, Scope가 끝나면 다끝이다.

    다른 라이브러리가 Coroutine을 실행시켰고 그것이 비동기로 돌아가고 있더라도, 그 라이브러리가 존재하는 Scope가 끝나버리면
    그 안의 Coroutine작업도 다 cancel되어 버리게 된다.

    Coroutine은 Scope로 시작되고 Scope단위로 끝나버리므로, 항상 Scope블럭을 관리하는데 주의를 기울여야 한다.

3 - 5. 작업할 쓰레드를 변경하는 방법
    withContext메소드를 이용하면, Coroutine의 context를 변경할 수 있다. context는 job이나 위에서 scope를 정할 때
    사용했었던, Dispatcher들에 대한 정보들을 담고 있다. withContext(Main)메소드를 이요하면, Dispatcher를 변경해서
    코틀린 코드가 실행되는 쓰레드를 변경할 수 있다.







